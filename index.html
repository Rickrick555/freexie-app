<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ãƒ›ãƒ¯ã‚¤ãƒˆãƒœãƒ¼ãƒ‰ã‚¢ãƒ—ãƒª</title>
    <!-- ä¸­å›½èªãƒ”ãƒ³ã‚¤ãƒ³å¤‰æ›ã¯è»½é‡(ç´„100KB)ãªãŸã‚ç¶™ç¶šä½¿ç”¨ -->
    <!-- pinyin-pro -->
    <script src="https://cdn.jsdelivr.net/npm/pinyin-pro@3.19.6/dist/index.js"></script>
    <style>
        /* ãƒªã‚»ãƒƒãƒˆã¨åŸºæœ¬è¨­å®š */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            min-height: 100dvh;
            background-color: #f5f5f7;
            color: #1d1d1f;
        }

        /* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚³ãƒ³ãƒ†ãƒŠ */
        #toolbar-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
            padding: 8px 16px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
            z-index: 10;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .tool-group {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
            color: #333;
        }

        select,
        button {
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid #d2d2d7;
            background: #ffffff;
            font-size: 14px;
            color: #1d1d1f;
            cursor: pointer;
            transition: all 0.2s ease;
            outline: none;
            touch-action: manipulation;
            /* ã‚¹ãƒãƒ›ã§ã®ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã‚ºãƒ¼ãƒ å¾…ã¡(300msé…å»¶)ã‚’è§£æ¶ˆã—åå¿œã‚’çˆ†é€Ÿã«ã™ã‚‹ */
        }

        input[type="range"] {
            cursor: pointer;
            accent-color: #007aff;
            width: 100px;
            touch-action: manipulation;
        }

        button:hover {
            background: #f5f5f7;
        }

        button:active {
            background: #e5e5ea;
            transform: scale(0.98);
        }

        /* ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆç”¨ */
        .color-palette {
            display: flex;
            gap: 4px;
            align-items: center;
            margin-right: 4px;
        }

        .color-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #ccc;
            cursor: pointer;
            padding: 0;
            transition: transform 0.1s, border-color 0.1s;
        }

        .color-btn:hover {
            transform: scale(1.1);
        }

        .color-btn.active {
            border-color: #333;
            transform: scale(1.1);
        }

        /* å³å¯„ã›ã®è¦ç´ ç”¨ */
        .push-right {
            margin-left: auto;
        }

        /* ãƒ¡ã‚¤ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹é ˜åŸŸ */
        #canvas-container {
            flex: 1;
            height: 100%;
            position: relative;
            border-bottom: 1px solid #c0c0c0;
            touch-action: none;
            overflow: hidden;
            perspective: 1000px;
        }

        /* æç”»ãƒ»ãƒ†ã‚­ã‚¹ãƒˆé ˜åŸŸã‚’ã¾ã¨ã‚ã‚‹å›ºå®šã‚µã‚¤ã‚ºã®B5ãƒ©ãƒƒãƒ‘ãƒ¼ */
        #canvas-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 1200px;
            height: 1697px;
            transform-origin: top left;
            background-color: #ffffff;
            touch-action: none;
            will-change: transform;
        }

        /* ãƒšãƒ¼ã‚¸ã‚ãã‚Šã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã‚¯ãƒ©ã‚¹ */
        .page-turn-next {
            animation: turnNext 0.4s ease-in-out forwards;
            transform-origin: left center;
        }

        .page-turn-prev {
            animation: turnPrev 0.4s ease-in-out forwards;
            transform-origin: right center;
        }

        @keyframes turnNext {
            0% {
                transform: rotateY(0deg);
                opacity: 1;
            }

            50% {
                transform: rotateY(-90deg);
                opacity: 0.5;
            }

            100% {
                transform: rotateY(0deg);
                opacity: 1;
            }
        }

        @keyframes turnPrev {
            0% {
                transform: rotateY(0deg);
                opacity: 1;
            }

            50% {
                transform: rotateY(90deg);
                opacity: 0.5;
            }

            100% {
                transform: rotateY(0deg);
                opacity: 1;
            }
        }

        /* ã‚­ãƒ£ãƒ³ãƒã‚¹è¦ç´  */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        /* draft-canvasã¯ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã‚’å—ã‘å–ã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹ */
        #draft-canvas {
            pointer-events: none;
        }

        /* èª¤ã‚¯ãƒªãƒƒã‚¯é˜²æ­¢ç”¨ã®ç‰©ç†ãƒãƒ¼ã‚¸ãƒ³ï¼ˆç©ºç™½ï¼‰ */
        .ad-spacer {
            height: 16px;
            background-color: transparent;
            flex-shrink: 0;
        }

        /* åºƒå‘Šã‚¨ãƒªã‚¢ */
        #ad-container {
            height: 90px;
            background-color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
            color: #888;
            font-size: 14px;
            font-weight: bold;
        }

        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– (ã‚¹ãƒãƒ›å‘ã‘) */
        @media (max-width: 767px) {
            #ad-container {
                height: 40px;
            }

            #toolbar-container {
                padding: 8px 10px;
            }

            .tools-section {
                flex-wrap: nowrap !important;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                padding-bottom: 4px;
                gap: 12px !important;
            }

            /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚’è¦‹ãˆãªãã™ã‚‹ */
            .tools-section::-webkit-scrollbar {
                display: none;
            }

            .tool-group {
                width: auto;
                flex-shrink: 0;
                font-size: 14px;
            }

            .tool-group>label {
                display: flex;
                flex-direction: row;
                align-items: center;
                gap: 6px;
                width: auto;
                white-space: nowrap;
            }

            .tool-group>label>select,
            .tool-group>label>input {
                width: auto;
                margin-top: 0;
            }

            select,
            button {
                font-size: 16px;
                padding: 10px 14px;
                min-height: 44px;
                /* ã‚¿ãƒƒãƒ—ã—ã‚„ã™ã */
            }

            input[type="range"] {
                width: 120px;
            }

            .color-btn {
                width: 32px;
                height: 32px;
            }

            .push-right {
                margin-left: 0;
                width: auto;
            }
        }

        /* --- èƒŒæ™¯ï¼ˆç´™è³ªï¼‰ã®ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š --- */
        .paper-kanji {
            background-color: #ffffff;
            background-image: url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120'%3E%3Crect width='120' height='120' fill='%23ffffff'/%3E%3Cpath d='M60 0 v120 M0 60 h120' stroke='%23b3e0f2' stroke-width='2' stroke-dasharray='6,6'/%3E%3Cpath d='M120 0 L0 0 0 120' fill='none' stroke='%2366c2eb' stroke-width='2'/%3E%3C/svg%3E");
            background-size: 120px 120px;
            background-position: top left;
        }

        .paper-vertical {
            background-color: #ffffff;
            background-image: url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='80' height='40'%3E%3Crect width='80' height='40' fill='%23ffffff'/%3E%3Cpath d='M40 0 v40' stroke='%23b3e0f2' stroke-width='2' stroke-dasharray='6,6'/%3E%3Cpath d='M0 0 v40' fill='none' stroke='%2366c2eb' stroke-width='2'/%3E%3C/svg%3E");
            background-size: 80px 40px;
            background-position: top right;
        }

        .paper-grid {
            background-color: #ffffff;
            background-image: url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30'%3E%3Crect width='30' height='30' fill='%23ffffff'/%3E%3Cpath d='M30 0 L0 0 0 30' fill='none' stroke='%2387ceeb' stroke-width='1'/%3E%3C/svg%3E");
            background-size: 30px 30px;
            background-position: top left;
        }

        .paper-horizontal {
            background-color: #ffffff;
            background-image: url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='40'%3E%3Crect width='40' height='40' fill='%23ffffff'/%3E%3Cpath d='M0 40 h40' fill='none' stroke='%2387ceeb' stroke-width='1.5'/%3E%3C/svg%3E");
            background-size: 40px 40px;
            background-position: top left;
        }

        .paper-tictactoe {
            background-color: #ffffff;
            background-image: none;
        }

        .paper-whiteboard {
            background-color: #ffffff;
            background-image: none;
        }

        /* --- ã‚¨ãƒ‡ã‚£ã‚¿ãƒ»æ©Ÿèƒ½è¿½åŠ ç”¨ --- */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            z-index: 9999;
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }

        .mode-toggles {
            display: flex;
            width: 100%;
            border-bottom: 2px solid #eee;
            padding-bottom: 8px;
            margin-bottom: 4px;
            gap: 10px;
        }

        .mode-btn {
            flex: 1;
            padding: 8px;
            font-weight: bold;
            border: 2px solid #ccc;
            background: #fff;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
        }

        .mode-btn.active {
            border-color: #0275d8;
            background: #e6f2ff;
            color: #0275d8;
        }

        .tools-section {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
        }

        /* ====== ãƒ†ã‚­ã‚¹ãƒˆãƒ¬ã‚¤ãƒ¤ãƒ¼ ====== */
        #text-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* ä¸‹ã®ã‚­ãƒ£ãƒ³ãƒã‚¹æ“ä½œã‚’å¦¨ã’ãªã„ */
            overflow: hidden;
        }

        /* æµ®è‹¦ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ */
        .floating-textbox {
            position: absolute;
            pointer-events: auto;
            /* è‡ªèº«ã¸ã®ã‚¯ãƒªãƒƒã‚¯ç­‰ã¯å—ã‘å–ã‚‹ */
            background: rgba(255, 255, 255, 0.5);
            /* ã†ã£ã™ã‚‰èƒŒæ™¯ã‚’ã¤ã‘ã¦æ´ã¿ã‚„ã™ã */
            border: 2px dashed rgba(0, 0, 0, 0.1);
            /* åˆæœŸçŠ¶æ…‹ã§ã‚‚æ ã‚’è–„ãè¡¨ç¤º */
            padding: 12px;
            /* ãƒ‰ãƒ©ãƒƒã‚°ç”¨ã®ä½™ç™½ã‚’å¤§ããç¢ºä¿ */
            border-radius: 8px;
            /* è§’ä¸¸ã§Macã‚‰ã—ã• */
            min-width: 50px;
            min-height: 30px;
            outline: none;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 2.2;
            /* ãƒ«ãƒ“ãŒé‡ãªã‚‰ãªã„ã‚ˆã†ã«åºƒã‚ */
            font-size: 24px;
            transform-origin: top left;
            transition: background 0.2s, border-color 0.2s;
        }

        .floating-textbox:hover {
            border-color: rgba(0, 122, 255, 0.5);
            background: rgba(255, 255, 255, 0.8);
        }

        .floating-textbox:focus {
            border-color: #007aff;
            background: rgba(255, 255, 255, 1.0);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        ruby {
            display: inline-ruby;
            ruby-align: center;
        }

        rt {
            cursor: pointer;
            color: #888;
            transition: color 0.1s;
            font-size: 0.5em;
            /* ãƒ«ãƒ“ã®ã‚µã‚¤ã‚ºæŒ‡å®š */
            line-height: 1;
            /* è¦ªãƒ†ã‚­ã‚¹ãƒˆã«å¹²æ¸‰ã•ã›ãªã„ */
        }

        rt:hover {
            color: #0275d8;
        }
    </style>
</head>

<body>

    <!-- ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ -->
    <div id="toolbar-container">
        <!-- æç”»ï¼†ãƒ†ã‚­ã‚¹ãƒˆãƒ„ãƒ¼ãƒ«ç¾¤ï¼ˆçµ±åˆï¼‰ -->
        <div id="draw-tools" class="tools-section">
            <div class="tool-group">
                <label><span class="i18n" data-ja="ç”¨ç´™:" data-en="Paper:">ç”¨ç´™:</span>
                    <select id="select-paper">
                        <option value="kanji" data-ja="æ¼¢å­—ãƒ‰ãƒªãƒ«" data-en="Kanji Drill">æ¼¢å­—ãƒ‰ãƒªãƒ«</option>
                        <option value="vertical" data-ja="ç¸¦æ›¸ã" data-en="Vertical">ç¸¦æ›¸ã</option>
                        <option value="grid" data-ja="æ–¹çœ¼ç´™" data-en="Grid">æ–¹çœ¼ç´™</option>
                        <option value="horizontal" data-ja="æ¨ªæ›¸ã" data-en="Horizontal">æ¨ªæ›¸ã</option>
                        <option value="tictactoe" data-ja="ãƒãƒ«ãƒãƒ„" data-en="Tic-Tac-Toe">ãƒãƒ«ãƒãƒ„</option>
                        <option value="none" data-ja="ç„¡åœ°" data-en="Plain">ç„¡åœ°</option>
                    </select>
                </label>
            </div>

            <div class="tool-group">
                <label><span class="i18n" data-ja="ç½«ç·šã®é–“éš”:" data-en="Line Spacing:">ç½«ç·šã®é–“éš”:</span>
                    <input type="range" id="input-grid-spacing" min="0.5" max="10.0" step="0.1" value="1.0"
                        style="width: 70px;">
                </label>
            </div>

            <div class="tool-group">
                <label><span class="i18n" data-ja="ãƒ„ãƒ¼ãƒ«:" data-en="Tool:">ãƒ„ãƒ¼ãƒ«:</span>
                    <select id="select-brush">
                        <option value="pencil" data-ja="é‰›ç­†(åŠé€æ˜)" data-en="Pencil">é‰›ç­†(åŠé€æ˜)</option>
                        <option value="fude" data-ja="ç­†ãƒšãƒ³" data-en="Fude Brush">ç­†ãƒšãƒ³</option>
                        <option value="ballpoint" data-ja="ãƒœãƒ¼ãƒ«ãƒšãƒ³" data-en="Ballpoint">ãƒœãƒ¼ãƒ«ãƒšãƒ³</option>
                        <option value="magic" data-ja="ãƒã‚¸ãƒƒã‚¯(å¤ªå­—)" data-en="Marker">ãƒã‚¸ãƒƒã‚¯(å¤ªå­—)</option>
                        <option value="eraser-partial" data-ja="æ¶ˆã—ã‚´ãƒ (éƒ¨åˆ†)" data-en="Eraser(Part)">æ¶ˆã—ã‚´ãƒ (éƒ¨åˆ†)</option>
                        <option value="eraser-stroke" data-ja="æ¶ˆã—ã‚´ãƒ (ç·šã”ã¨)" data-en="Eraser(Line)">æ¶ˆã—ã‚´ãƒ (ç·šã”ã¨)</option>
                    </select>
                </label>
            </div>

            <div class="tool-group">
                <button id="btn-add-text" class="i18n" data-ja="ğŸ“ ãƒ†ã‚­ã‚¹ãƒˆè¿½åŠ " data-en="Add Text"
                    style="border-color: #007aff; color: #007aff; font-weight: bold;">ğŸ“ ãƒ†ã‚­ã‚¹ãƒˆè¿½åŠ </button>
            </div>

            <div class="tool-group">
                <label style="display: flex; align-items: center;"><span class="i18n" data-ja="è‰²:"
                        data-en="Color:">è‰²:</span>
                    <div class="color-palette" id="color-palette">
                        <button class="color-btn active" style="background-color: #333333;"
                            data-color="#333333"></button>
                        <button class="color-btn" style="background-color: #e63946;" data-color="#e63946"></button>
                        <button class="color-btn" style="background-color: #005f73;" data-color="#005f73"></button>
                        <button class="color-btn" style="background-color: #2a9d8f;" data-color="#2a9d8f"></button>
                    </div>
                    <input type="color" id="input-color" value="#333333" title="è‡ªç”±ãªè‰²ã‚’é¸ã¶"
                        style="width: 32px; height: 32px; padding: 0; border: none; background: transparent; cursor: pointer;">
                </label>
            </div>

            <div class="tool-group">
                <label><span class="i18n" data-ja="ç·šã®å¤ªã•:" data-en="Thickness:">ç·šã®å¤ªã•:</span>
                    <input type="range" id="input-thickness" min="1" max="50" value="10">
                </label>
            </div>

            <div class="tool-group page-controls push-right">
                <button id="btn-prev" class="i18n" data-ja="å‰ã¸" data-en="Prev">å‰ã¸</button>
                <span id="page-display">1 / 1</span>
                <button id="btn-next" class="i18n" data-ja="æ¬¡ã¸(æ–°è¦)" data-en="Next(New)">æ¬¡ã¸(æ–°è¦)</button>
            </div>

            <div class="tool-group push-right">
                <button id="btn-stroke-order" class="i18n" data-ja="ç­†é †ç•ªå·(ã‚ªãƒ•)" data-en="Stroke Order(Off)"
                    style="border-color: #d2d2d7; color: #1d1d1f; font-weight: bold;">ç­†é †ç•ªå·(ã‚ªãƒ•)</button>
                <button id="btn-undo" class="i18n" data-ja="ã‚„ã‚Šç›´ã—" data-en="Undo"
                    style="border-color: #d2d2d7;">ã‚„ã‚Šç›´ã—</button>
                <button id="btn-clear" class="i18n" data-ja="å…¨æ¶ˆå»" data-en="Clear All"
                    style="color: #ff3b30; border-color: #ff3b30;">å…¨æ¶ˆå»</button>
                <button id="btn-save" class="i18n" data-ja="ä¿å­˜(PNG)" data-en="Save(PNG)"
                    style="background-color: #007aff; color: white; border: none;">ä¿å­˜(PNG)</button>
            </div>

            <!-- ãƒ«ãƒ“é–¢é€£æ©Ÿèƒ½ï¼ˆãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æ™‚ã«æœ‰åŠ¹åŒ–ã•ã‚Œã‚‹ï¼‰ -->
            <div class="tool-group" id="ruby-tools"
                style="opacity: 0.5; pointer-events: none; transition: opacity 0.2s;">
                <label><span class="i18n" data-ja="ãƒ•ã‚©ãƒ³ãƒˆ:" data-en="Font Size:">ãƒ•ã‚©ãƒ³ãƒˆ:</span>
                    <input type="number" id="input-font-size" value="24" min="10" max="100"
                        style="width: 50px; border: 1px solid #d2d2d7; border-radius: 4px; padding: 2px 4px; font-size: 14px;">
                </label>
                <label><span class="i18n" data-ja="ãƒ«ãƒ“(ãƒ”ãƒ³ã‚¤ãƒ³)è¨€èª:" data-en="Ruby(Pinyin) Lang:">ãƒ«ãƒ“(ãƒ”ãƒ³ã‚¤ãƒ³)è¨€èª:</span>
                    <select id="select-ruby-lang" style="width: auto;">
                        <option value="ja" data-ja="æ—¥æœ¬èª" data-en="Japanese">æ—¥æœ¬èª</option>
                        <option value="zh" data-ja="ä¸­å›½èª" data-en="Chinese">ä¸­å›½èª</option>
                    </select>
                </label>
                <button id="btn-auto-ruby" class="i18n" data-ja="ãƒ«ãƒ“è¿½åŠ /è‡ªå‹•" data-en="Add Ruby"
                    style="border-color: #007aff; color: #007aff; font-weight: bold; margin-left: 10px;">ãƒ«ãƒ“è¿½åŠ /è‡ªå‹•</button>
            </div>

            <div class="tool-group">
                <label style="flex-direction: row; align-items: center; justify-content: flex-end;">
                    <select id="select-lang" style="width: auto; margin-top: 0;">
                        <option value="ja">æ—¥æœ¬èª</option>
                        <option value="en">English</option>
                    </select>
                </label>
            </div>
        </div>
    </div>

    <!-- ãƒ¡ã‚¤ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒ»ãƒ†ã‚­ã‚¹ãƒˆé ˜åŸŸ -->
    <div id="canvas-container">
        <!-- æç”»ï¼†èƒŒæ™¯ç”¨ã®B5å›ºå®šãƒ©ãƒƒãƒ‘ãƒ¼ (1200x1697) -->
        <div id="canvas-wrapper" class="paper-kanji">
            <!-- ç¢ºå®šã•ã‚ŒãŸæç”»ã‚’ä¿æŒã™ã‚‹ã‚­ãƒ£ãƒ³ãƒã‚¹ -->
            <canvas id="main-canvas" width="1200" height="1697"></canvas>
            <!-- ç¾åœ¨ã®ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚’æå†™ã™ã‚‹ä¸€æ™‚ã‚­ãƒ£ãƒ³ãƒã‚¹ -->
            <canvas id="draft-canvas" width="1200" height="1697"></canvas>
            <!-- ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ -->
            <div id="text-layer"></div>
        </div>
    </div>

    <!-- æº–å‚™ä¸­ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
    <div id="loading-overlay" style="flex-direction: column; text-align: center; line-height: 1.5;">
        æº–å‚™ä¸­... / Loading...<br>
        <span style="font-size: 0.85em; opacity: 0.9; margin-top: 8px;">
            ãƒ«ãƒ“è¾æ›¸ãƒ‡ãƒ¼ã‚¿(ç´„17MB)ã‚’æº–å‚™ã—ã¦ã„ã¾ã™ã€‚<br>
            <strong style="color: #ff3b30;">â€»ã“ã®å¤§å®¹é‡é€šä¿¡ã¯åˆå›ã®ã¿ç™ºç”Ÿã—ã¾ã™</strong>
        </span>
        <div id="dict-progress" style="margin-top: 8px; font-weight: bold; color: #007aff;"></div>
    </div>

    <!-- ç‰©ç†ãƒãƒ¼ã‚¸ãƒ³ -->
    <div class="ad-spacer"></div>

    <!-- åºƒå‘Šã‚¨ãƒªã‚¢ -->
    <div id="ad-container">
        <span>åºƒå‘Šã‚¨ãƒªã‚¢ (Ad Container)</span>
    </div>

    <script>
        // DOMè¦ç´ ã®å–å¾—
        const drawTools = document.getElementById('draw-tools');
        const rubyTools = document.getElementById('ruby-tools');

        const container = document.getElementById('canvas-container');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const mainCanvas = document.getElementById('main-canvas');
        const mainCtx = mainCanvas.getContext('2d', { willReadFrequently: true });
        const draftCanvas = document.getElementById('draft-canvas');
        const draftCtx = draftCanvas.getContext('2d');
        const textLayer = document.getElementById('text-layer');

        const paperSelect = document.getElementById('select-paper');
        const gridSpacingInput = document.getElementById('input-grid-spacing');
        const brushSelect = document.getElementById('select-brush');
        const colorInput = document.getElementById('input-color');
        const colorBtns = document.querySelectorAll('.color-btn');
        const thicknessInput = document.getElementById('input-thickness');
        const pageDisplay = document.getElementById('page-display');
        const langSelect = document.getElementById('select-lang');

        // å¤šè¨€èªç¿»è¨³æ©Ÿèƒ½
        function updateLanguage(lang) {
            // ã‚¹ãƒ‘ãƒ³ã‚„ãƒœã‚¿ãƒ³ã®ç¿»è¨³
            document.querySelectorAll('.i18n').forEach(el => {
                if (el.dataset[lang]) {
                    el.textContent = el.dataset[lang];
                }
            });
            // ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹å†…ã®optionã®ç¿»è¨³
            document.querySelectorAll('option[data-ja]').forEach(opt => {
                if (opt.dataset[lang]) {
                    opt.textContent = opt.dataset[lang];
                }
            });
        }

        langSelect.addEventListener('change', (e) => updateLanguage(e.target.value));

        // ãƒ–ãƒ©ã‚·ã®ç¨®é¡ã¨è¨­å®š
        const brushSettings = {
            // widthMult: ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼å€¤ã¸ã®å€ç‡, alpha: é€æ˜åº¦
            pencil: { widthMult: 0.4, alpha: 0.85 },
            fude: { widthMult: 1.0, alpha: 1.0 },
            magic: { widthMult: 1.5, alpha: 0.5 },
            ballpoint: { widthMult: 0.15, alpha: 0.95 },
            'eraser-partial': { widthMult: 2.0, alpha: 1.0 },
            'eraser-stroke': { widthMult: 2.0, alpha: 1.0 }
        };

        // çŠ¶æ…‹å¤‰æ•°
        let currentMode = 'draw'; // 'draw' ã¾ãŸã¯ 'text'
        let isDrawing = false;
        let points = [];
        let lastTimestamp = 0;
        let lastFudeWidth = 0;
        let currentColor = '#333333';

        // ç­†é †ç•ªå·ãƒ¢ãƒ¼ãƒ‰
        let isStrokeOrderMode = false;
        let currentStrokeCount = 0;

        const btnStrokeOrder = document.getElementById('btn-stroke-order');
        btnStrokeOrder.addEventListener('click', () => {
            isStrokeOrderMode = !isStrokeOrderMode;
            if (isStrokeOrderMode) {
                btnStrokeOrder.style.borderColor = '#ff3b30';
                btnStrokeOrder.style.color = '#ff3b30';
                const lang = langSelect.value;
                btnStrokeOrder.textContent = lang === 'en' ? 'Stroke Order(On)' : 'ç­†é †ç•ªå·(ã‚ªãƒ³)';
                btnStrokeOrder.dataset.ja = 'ç­†é †ç•ªå·(ã‚ªãƒ³)';
                btnStrokeOrder.dataset.en = 'Stroke Order(On)';
            } else {
                btnStrokeOrder.style.borderColor = '#d2d2d7';
                btnStrokeOrder.style.color = '#1d1d1f';
                const lang = langSelect.value;
                btnStrokeOrder.textContent = lang === 'en' ? 'Stroke Order(Off)' : 'ç­†é †ç•ªå·(ã‚ªãƒ•)';
                btnStrokeOrder.dataset.ja = 'ç­†é †ç•ªå·(ã‚ªãƒ•)';
                btnStrokeOrder.dataset.en = 'Stroke Order(Off)';
            }
        });

        // æ¶ˆã—ã‚´ãƒ (ç·šã”ã¨)ç”¨ã®ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å±¥æ­´
        let strokeHistory = [];
        let currentStrokes = []; // ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã®ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ç¾¤

        // Undoå±¥æ­´ç”¨ã®é…åˆ— (ãƒšãƒ¼ã‚¸ã”ã¨ã«åˆ¥ç®¡ç†ã›ãšã€ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã«å¯¾ã™ã‚‹Undoã®ç°¡æ˜“å®Ÿè£…)
        let undoStack = [];

        // è‰²å¤‰æ›´ã®å‡¦ç†
        function setColor(newColor) {
            currentColor = newColor;
            colorInput.value = newColor;
            // ãƒ‘ãƒ¬ãƒƒãƒˆã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’æ›´æ–°
            colorBtns.forEach(btn => {
                if (btn.dataset.color.toLowerCase() === newColor.toLowerCase()) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        colorBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®é€ä¿¡æŒ™å‹•ã‚’é˜²ã
                e.preventDefault();
                setColor(btn.dataset.color);
            });
        });

        colorInput.addEventListener('input', (e) => {
            setColor(e.target.value);
        });

        // ãƒšãƒ¼ã‚¸ç®¡ç†ç”¨ã®ImageDataã¨ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹é…åˆ—
        let pages = [];
        let currentPageIndex = 0;

        // ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã®ä¸€æ„ã®IDã‚«ã‚¦ãƒ³ã‚¿
        let textboxIdCounter = 0;
        let activeTextbox = null;

        // ãƒ„ãƒ¼ãƒ«åˆ‡ã‚Šæ›¿ãˆæ™‚ã«ãƒ«ãƒ“ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®æœ‰åŠ¹åŒ–ãªã©ã‚’ç›£è¦–
        brushSelect.addEventListener('change', (e) => {
            if (e.target.value === 'text') {
                container.style.cursor = 'text';
            } else {
                container.style.cursor = 'crosshair';
            }
        });

        /**
         * ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ç”»é¢ã«åˆã‚ã›ã¦åˆæœŸåŒ–ï¼ˆB5å›ºå®šã‚µã‚¤ã‚ºï¼‹ãƒ‘ãƒ³ãƒ»ã‚ºãƒ¼ãƒ ï¼‰
         */
        function initCanvasSize() {
            const rect = container.getBoundingClientRect();
            if (rect.width > 0) {
                // ã‚¹ãƒãƒ›ãªã©ã®ç”»é¢å¹…ã«åˆã‚ã›ã¦B5(1200px)ãŒåã¾ã‚‹ã‚ˆã†ã«åˆæœŸã‚ºãƒ¼ãƒ ã‚’è¨­å®š
                currentZoomScale = Math.min(1.0, rect.width / 1200);

                // çœŸã‚“ä¸­ä»˜è¿‘ã«ãªã‚‹ã‚ˆã†ã«Xåº§æ¨™ã‚’èª¿æ•´
                currentTranslateX = (rect.width - (1200 * currentZoomScale)) / 2;
                currentTranslateY = 10; // å°‘ã—ä¸Šéƒ¨ã«ä½™ç™½
                applyZoom();
            }
        }

        // åˆæœŸåŒ–ãƒ»ãƒªã‚µã‚¤ã‚ºç›£è¦–
        window.addEventListener('resize', initCanvasSize);
        // ç›´ã¡ã«1å›å®Ÿè¡Œ
        initCanvasSize();

        /**
         * ãƒšãƒ³ãƒ»æŒ‡ã®ã‚¿ãƒƒãƒé–‹å§‹ (ã¾ãŸã¯ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹é…ç½®)
         */
        function handlePointerDown(e) {
            if (e.target !== mainCanvas && e.target !== draftCanvas && e.target !== textLayer) return;

            let brushType = brushSelect.value;
            const rect = canvasWrapper.getBoundingClientRect();
            const x = (e.clientX - rect.left) / currentZoomScale;
            const y = (e.clientY - rect.top) / currentZoomScale;

            if (isPinching) return; // ãƒ”ãƒ³ãƒä¸­ã¯æç”»ã—ãªã„
            if (window.isTextPlacementMode) return; // ãƒ†ã‚­ã‚¹ãƒˆé…ç½®å¾…æ©Ÿä¸­ã¯æç”»ã•ã›ãªã„

            isDrawing = true;
            lastTimestamp = e.timeStamp;

            let baseThick = Number(thicknessInput.value);

            // æ¶ˆã—ã‚´ãƒ ç³»ä»¥å¤–ãªã‚‰ç¾åœ¨ã®ç­†é †ç•ªå·ã‚’ç¢ºå®š
            let assignedOrder = null;
            if (brushType !== 'eraser-stroke' && brushType !== 'eraser-partial') {
                if (isStrokeOrderMode) {
                    currentStrokeCount++;
                    assignedOrder = currentStrokeCount;
                }
            }

            // ç­†ãƒšãƒ³ã®æãå§‹ã‚ã‚’å¤ªãã—ã¦ã€Œã¨ã‚ã€ã‚’ã—ã£ã‹ã‚Šè¡¨ç¾ã™ã‚‹ï¼ˆ1.5å€ï¼‰
            lastFudeWidth = brushType === 'fude' ? baseThick * 1.5 : baseThick;

            points = [{ x, y, width: lastFudeWidth, color: currentColor, type: brushType, order: assignedOrder }];

            // æç”»é–‹å§‹æ™‚ã«ç¾åœ¨ã®çŠ¶æ…‹ã‚’Undoã‚¹ã‚¿ãƒƒã‚¯ã«ç©ã‚€
            saveUndoState();

            if (brushType === 'eraser-stroke') {
                eraseStrokeAt(x, y);
            } else if (brushType === 'eraser-partial') {
                erasePartialAt(x, y, baseThick * brushSettings['eraser-partial'].widthMult);
            } else {
                // draftCanvasã«ã¯ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã®ç·šã ã‘ã‚’æãã€ç•ªå·è‡ªä½“ã¯ã“ã“ã§ã¯æ›¸ã‹ãªã„
                // ç•ªå·ã¯ mainCtx ã«ç¢ºå®šã•ã›ã‚‹ãŸã‚ã€handlePointerUpæ™‚ã¾ãŸã¯å³æ™‚ã«mainCtxã«æ›¸ãã‹ã€
                // ã‚ã‚‹ã„ã¯ redrawAllStrokes ã¨ draftæç”» ã‚’èª¿æ•´ã™ã‚‹ã€‚
                // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ€§ã‚’é«˜ã‚ã‚‹ãŸã‚ mainCtx ã«ç›´æ¥ç•ªå·ã‚’æãã¾ã™
                if (assignedOrder) {
                    drawStrokeNumber(mainCtx, x, y, assignedOrder);
                }
                drawDraftPath();
            }
        }

        /**
         * ãƒšãƒ³ãƒ»æŒ‡ã®ç§»å‹•
         */
        function handlePointerMove(e) {
            if (!isDrawing) return;

            const rect = canvasWrapper.getBoundingClientRect();
            const x = (e.clientX - rect.left) / currentZoomScale;
            const y = (e.clientY - rect.top) / currentZoomScale;

            let brushType = brushSelect.value;
            let baseThick = Number(thicknessInput.value);
            let currentWidth = baseThick;

            // ç­†ãƒšãƒ³ã®å ´åˆï¼šã¨ã‚ã€ã¯ã­ã®ãƒ¡ãƒªãƒãƒªã‚’æŒãŸã›ã‚‹
            if (brushType === 'fude') {
                let lastPoint = points[points.length - 1];
                let dist = Math.hypot(x - lastPoint.x, y - lastPoint.y);
                let dt = e.timeStamp - lastTimestamp;
                let velocity = (dt > 0) ? (dist / dt) : 0;

                // é€Ÿåº¦ã«ã‚ˆã‚‹å¤ªã•ã®èª¿æ•´ï¼ˆé…ã„=å¤ªã„[æœ€å¤§1.5å€]ã€é€Ÿã„=ç´°ã„[æœ€å°0.1å€]ï¼‰
                let speedFactor = Math.min(1.0, velocity / 2.5); // 0(é…)ã€œ1(é€Ÿ)ã®å‰²åˆ
                let targetWidth = baseThick * (1.5 - speedFactor * 1.4);
                targetWidth = Math.max(baseThick * 0.1, targetWidth);

                // ã¯ã‚‰ã†ï¼ˆé€Ÿã„ï¼‰æ™‚ã¯å¤ªã•ã®å¤‰åŒ–ã‚’ä¿Šæ•ã«ã—ã€ã¨ã‚ã‚‹ï¼ˆé…ã„ï¼‰æ™‚ã¯ã˜ã‚ã£ã¨å¤‰åŒ–ã•ã›ã‚‹
                let smoothWeight = velocity > 1.5 ? 0.35 : 0.15;
                currentWidth = lastFudeWidth * (1 - smoothWeight) + targetWidth * smoothWeight;
                lastFudeWidth = currentWidth;
            }

            lastTimestamp = e.timeStamp;
            points.push({ x, y, width: currentWidth, color: currentColor, type: brushType });

            if (brushType === 'eraser-stroke') {
                eraseStrokeAt(x, y);
            } else if (brushType === 'eraser-partial') {
                erasePartialAt(x, y, baseThick * brushSettings['eraser-partial'].widthMult);
            } else {
                drawDraftPath();
            }
        }

        /**
         * ãƒšãƒ³ãƒ»æŒ‡ã®ã‚¿ãƒƒãƒçµ‚äº†
         */
        function handlePointerUp(e) {
            if (!isDrawing) return;
            isDrawing = false;

            let brushType = brushSelect.value;

            if (brushType !== 'eraser-stroke' && brushType !== 'eraser-partial') {
                // æœ€çµ‚ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚’æå†™ã—ç¢ºå®š
                drawDraftPath();
                mainCtx.drawImage(draftCanvas, 0, 0);
                draftCtx.clearRect(0, 0, draftCanvas.width, draftCanvas.height);

                // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚’è¨˜éŒ²ï¼ˆç·šã”ã¨æ¶ˆã—ã‚´ãƒ ç”¨ï¼‰
                if (points.length > 0) {
                    currentStrokes.push([...points]);
                }
            }

            // æç”»å¾Œã€ç¾åœ¨ã®çŠ¶æ…‹ã‚’ãƒšãƒ¼ã‚¸ã¨ã—ã¦ä¿å­˜
            saveCurrentPage();
        }

        /**
         * ã“ã™ã‚‹æ¶ˆã—ã‚´ãƒ ã®å®Ÿè£…
         */
        function erasePartialAt(x, y, radius) {
            mainCtx.save();
            mainCtx.globalCompositeOperation = 'destination-out';
            mainCtx.beginPath();
            mainCtx.arc(x, y, radius / 2, 0, Math.PI * 2, false);
            mainCtx.fill();
            mainCtx.restore();

            // ã“ã™ã£ãŸéƒ¨åˆ†ã¯ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ç®¡ç†ã‚’ç ´å£Šã™ã‚‹ãŸã‚ã€ä¾¿å®œä¸Šã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å±¥æ­´ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹ã‹å†æ§‹æˆã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒ
            // ã“ã“ã§ã¯ç°¡æ˜“çš„ã«å…±å­˜ã•ã›ã‚‹ï¼ˆå³å¯†ãªä¸¡ç«‹ã¯ã‚­ãƒ£ãƒ³ãƒã‚¹å†æç”»ãŒå¿…è¦ï¼‰
        }

        /**
         * ç·šã”ã¨æ¶ˆã—ã‚´ãƒ ã®å®Ÿè£…ï¼ˆäº¤å·®åˆ¤å®šï¼‰
         */
        function eraseStrokeAt(x, y) {
            const hitRadius = 15; // å½“ãŸã‚Šåˆ¤å®šã®åºƒã•

            let hitIndex = -1;
            for (let i = currentStrokes.length - 1; i >= 0; i--) {
                const strokePoints = currentStrokes[i];
                for (const p of strokePoints) {
                    const dx = p.x - x;
                    const dy = p.y - y;
                    if (dx * dx + dy * dy <= hitRadius * hitRadius) {
                        hitIndex = i;
                        break;
                    }
                }
                if (hitIndex !== -1) break;
            }

            if (hitIndex !== -1) {
                // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚’å‰Šé™¤ã—ã€ã‚­ãƒ£ãƒ³ãƒã‚¹å…¨ä½“ã‚’å†æç”»
                currentStrokes.splice(hitIndex, 1);
                redrawAllStrokes();
            }
        }

        /**
         * è¨˜éŒ²ã•ã‚ŒãŸå…¨ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚’å†æç”»ã™ã‚‹ï¼ˆç·šã”ã¨æ¶ˆã—ã‚´ãƒ ç”¨ï¼‰
         */
        function redrawAllStrokes() {
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);

            currentStrokes.forEach(stroke => {
                if (stroke.length === 0) return;

                let startP = stroke[0];
                let type = startP.type;
                let col = startP.color;
                let setting = brushSettings[type] || brushSettings['pencil'];

                mainCtx.lineCap = 'round';
                mainCtx.lineJoin = 'round';
                mainCtx.strokeStyle = col;
                mainCtx.fillStyle = col;
                mainCtx.globalAlpha = setting.alpha;

                if (stroke.length === 1) {
                    mainCtx.lineWidth = startP.width * setting.widthMult;
                    mainCtx.beginPath();
                    mainCtx.arc(startP.x, startP.y, mainCtx.lineWidth / 2, 0, Math.PI * 2);
                    mainCtx.fill();
                } else if (type === 'fude') {
                    drawFudeStroke(mainCtx, stroke);
                } else {
                    mainCtx.lineWidth = startP.width * setting.widthMult; // ç°¡æ˜“åŒ–
                    mainCtx.beginPath();
                    mainCtx.moveTo(startP.x, startP.y);
                    for (let i = 1; i < stroke.length - 1; i++) {
                        let p1 = stroke[i];
                        let p2 = stroke[i + 1];
                        let xc = (p1.x + p2.x) / 2;
                        let yc = (p1.y + p2.y) / 2;
                        mainCtx.quadraticCurveTo(p1.x, p1.y, xc, yc);
                    }
                    let lastP = stroke[stroke.length - 1];
                    mainCtx.lineTo(lastP.x, lastP.y);
                    mainCtx.stroke();
                }

                // ç­†é †ç•ªå·ãŒã‚ã‚Œã°æç”»
                if (startP.order) {
                    drawStrokeNumber(mainCtx, startP.x, startP.y, startP.order);
                }
            });
        }

        // â—¯ä»˜ãã®æ•°å­—ï¼ˆâ‘ ã€â‘¡ç­‰ï¼‰ã‚’è¡¨ç¾ã™ã‚‹é…åˆ—ï¼ˆä»Šå›ã¯ãƒ•ã‚©ãƒ³ãƒˆã®éƒ½åˆç­‰ã‚‚è€ƒæ…®ã—å‹•çš„ç”Ÿæˆã™ã‚‹ã‹æ—¢å­˜ã®æ–‡å­—ã‚’ä½¿ã„ã¾ã™ï¼‰
        // 50ç”»ã¾ã§å¯¾å¿œï¼ˆå®Ÿç”¨çš„ã«ã¯ååˆ†ï¼‰
        const circledNumbers = ['â‘ ', 'â‘¡', 'â‘¢', 'â‘£', 'â‘¤', 'â‘¥', 'â‘¦', 'â‘§', 'â‘¨', 'â‘©',
            'â‘ª', 'â‘«', 'â‘¬', 'â‘­', 'â‘®', 'åå…­', 'â‘°', 'â‘±', 'â‘²', 'â‘³',
            'ã‰‘', 'ã‰’', 'ã‰“', 'ã‰”', 'ã‰•', 'ã‰–', 'ã‰—', 'ã‰˜', 'ã‰™', 'ã‰š',
            'ã‰›', 'ã‰œ', 'ã‰', 'ã‰', 'ã‰Ÿ', 'ãŠ±', 'ãŠ²', 'ãŠ³', 'ãŠ´', 'ãŠµ',
            'ãŠ¶', 'ãŠ·', 'ãŠ¸', 'ãŠ¹', 'ãŠº', 'ãŠ»', 'ãŠ¼', 'ãŠ½', 'ãŠ¾', 'ãŠ¿'];

        /**
         * ç­†é †ã®ç•ªå·ã‚’æç”»ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
         */
        function drawStrokeNumber(ctx, x, y, num) {
            ctx.save();
            ctx.globalAlpha = 1.0;
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // ç™½ã„ç¸å–ã‚Šã‚’å…¥ã‚Œã¦è¦‹ã‚„ã™ãã™ã‚‹
            ctx.lineWidth = 3;
            ctx.strokeStyle = 'white';
            ctx.strokeText(num <= 50 ? circledNumbers[num - 1] : num, x, y - 10);

            ctx.fillStyle = '#ff0000'; // èµ¤è‰²
            ctx.fillText(num <= 50 ? circledNumbers[num - 1] : num, x, y - 10);
            ctx.restore();
        }

        /**
         * ç¾åœ¨ã®ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚’ä¸€æ™‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã«æ»‘ã‚‰ã‹ã«æç”»ã™ã‚‹
         */
        function drawDraftPath() {
            draftCtx.clearRect(0, 0, draftCanvas.width, draftCanvas.height);
            if (points.length === 0) return;

            let brushType = brushSelect.value;
            let setting = brushSettings[brushType];
            let baseThick = Number(thicknessInput.value);

            draftCtx.lineCap = 'round';
            draftCtx.lineJoin = 'round';
            draftCtx.strokeStyle = currentColor;
            draftCtx.fillStyle = currentColor;
            draftCtx.globalAlpha = setting.alpha;

            // 1ç‚¹ã—ã‹ãªã„å ´åˆï¼ˆã‚¿ãƒƒãƒ—ã®ã¿ï¼‰
            if (points.length === 1) {
                draftCtx.lineWidth = setting.widthMult * baseThick;
                draftCtx.beginPath();
                draftCtx.arc(points[0].x, points[0].y, draftCtx.lineWidth / 2, 0, Math.PI * 2);
                draftCtx.fill();
                return;
            }

            if (brushType === 'fude') {
                // ç­†ãƒšãƒ³ï¼šæ»‘ã‚‰ã‹ãªãƒ™ã‚¸ã‚§æ›²ç·šã¨å¤ªã•è£œé–“ã‚’ç”¨ã„ã¦æç”»
                drawFudeStroke(draftCtx, points);
            } else {
                // ãã®ä»–ã®ãƒšãƒ³ï¼šQuadratic Curveã‚’ç”¨ã„ã¦å…¨ä½“ã‚’æ»‘ã‚‰ã‹ã«æç”»ï¼ˆä¸€ç­†æ›¸ãï¼‰
                draftCtx.lineWidth = setting.widthMult * baseThick;
                draftCtx.beginPath();
                draftCtx.moveTo(points[0].x, points[0].y);

                for (let i = 1; i < points.length - 1; i++) {
                    let p1 = points[i];
                    let p2 = points[i + 1];
                    // ä¸­ç‚¹ã‚’åˆ¶å¾¡ç‚¹ã¨ã™ã‚‹
                    let xc = (p1.x + p2.x) / 2;
                    let yc = (p1.y + p2.y) / 2;
                    draftCtx.quadraticCurveTo(p1.x, p1.y, xc, yc);
                }

                let lastParams = points[points.length - 1];
                draftCtx.lineTo(lastParams.x, lastParams.y);
                draftCtx.stroke();
            }
        }

        /**
         * ç­†ãƒšãƒ³ï¼ˆFudeï¼‰ã®æ»‘ã‚‰ã‹ãªã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚’æç”»ã™ã‚‹é–¢æ•°
         */
        function drawFudeStroke(ctx, strokePoints) {
            if (!strokePoints || strokePoints.length === 0) return;
            if (strokePoints.length === 1) {
                ctx.beginPath();
                ctx.arc(strokePoints[0].x, strokePoints[0].y, strokePoints[0].width / 2, 0, Math.PI * 2);
                ctx.fill();
                return;
            }
            if (strokePoints.length === 2) {
                drawInterpolatedLine(ctx, strokePoints[0], strokePoints[1]);
                return;
            }

            // æœ€åˆã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼ˆp0ã‹ã‚‰p0-p1ã®ä¸­ç‚¹ã¾ã§ï¼‰
            let p0 = strokePoints[0];
            let p1 = strokePoints[1];
            let mid01 = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2, width: (p0.width + p1.width) / 2 };
            drawInterpolatedLine(ctx, p0, mid01);

            // ä¸­é–“ã®æ›²ç·šï¼ˆ Quadratic Curve ã‚’è£œé–“ã—ã¦å††ã‚’æç”» ï¼‰
            for (let i = 1; i < strokePoints.length - 1; i++) {
                let pCur = strokePoints[i];
                let pNext = strokePoints[i + 1];
                let start = { x: (strokePoints[i - 1].x + pCur.x) / 2, y: (strokePoints[i - 1].y + pCur.y) / 2, width: (strokePoints[i - 1].width + pCur.width) / 2 };
                let end = { x: (pCur.x + pNext.x) / 2, y: (pCur.y + pNext.y) / 2, width: (pCur.width + pNext.width) / 2 };

                let dist = Math.hypot(end.x - start.x, end.y - start.y);
                let steps = Math.max(1, Math.floor(dist)); // 1pxã”ã¨ã«æç”»

                for (let j = 0; j <= steps; j++) {
                    let t = j / steps;
                    let xt = Math.pow(1 - t, 2) * start.x + 2 * (1 - t) * t * pCur.x + Math.pow(t, 2) * end.x;
                    let yt = Math.pow(1 - t, 2) * start.y + 2 * (1 - t) * t * pCur.y + Math.pow(t, 2) * end.y;
                    let wt = Math.pow(1 - t, 2) * start.width + 2 * (1 - t) * t * pCur.width + Math.pow(t, 2) * end.width;

                    ctx.beginPath();
                    ctx.arc(xt, yt, Math.max(0.5, wt / 2), 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // æœ€å¾Œã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼ˆæœ€å¾Œã‹ã‚‰2ç•ªç›®ã®ä¸­ç‚¹ã‹ã‚‰pLastã¾ã§ï¼‰
            let pLast = strokePoints[strokePoints.length - 1];
            let pPrev = strokePoints[strokePoints.length - 2];
            let midLast = { x: (pPrev.x + pLast.x) / 2, y: (pPrev.y + pLast.y) / 2, width: (pPrev.width + pLast.width) / 2 };
            drawInterpolatedLine(ctx, midLast, pLast);
        }

        function drawInterpolatedLine(ctx, pStart, pEnd) {
            let dist = Math.hypot(pEnd.x - pStart.x, pEnd.y - pStart.y);
            let steps = Math.max(1, Math.floor(dist));
            for (let j = 0; j <= steps; j++) {
                let t = j / steps;
                let xt = pStart.x + (pEnd.x - pStart.x) * t;
                let yt = pStart.y + (pEnd.y - pStart.y) * t;
                let wt = pStart.width + (pEnd.width - pStart.width) * t;
                ctx.beginPath();
                ctx.arc(xt, yt, Math.max(0.5, wt / 2), 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®ç™»éŒ²ï¼ˆPointer Events APIï¼‰
        canvasWrapper.addEventListener('pointerdown', handlePointerDown);
        // moveã‚„upã‚‚windowã¾ãŸã¯canvasã«ç´ã¥ã‘å¯èƒ½
        window.addEventListener('pointermove', handlePointerMove, { passive: false });
        window.addEventListener('pointerup', handlePointerUp);
        window.addEventListener('pointercancel', handlePointerUp);

        /**
         * ãƒšãƒ¼ã‚¸ç®¡ç†æ©Ÿèƒ½
         */
        function updatePageUI() {
            let total = Math.max(pages.length, 1);
            pageDisplay.textContent = `${currentPageIndex + 1} / ${total}`;
        }

        // ãƒšãƒ¼ã‚¸ã®çŠ¶æ…‹ã‚’ä¿å­˜ãƒ»å¾©å…ƒ
        // ==========================================

        function saveCurrentPage() {
            // ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã®æƒ…å ±ã‚’åé›†
            const textboxesData = [];
            const boxes = textLayer.querySelectorAll('.floating-textbox');
            boxes.forEach(box => {
                textboxesData.push({
                    id: box.id,
                    x: box.style.left,
                    y: box.style.top,
                    html: box.innerHTML,
                    color: box.style.color,
                    fontSize: box.style.fontSize
                });
            });

            pages[currentPageIndex] = {
                data: mainCtx.getImageData(0, 0, mainCanvas.width, mainCanvas.height),
                strokes: JSON.parse(JSON.stringify(currentStrokes)), // ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼
                zoomScale: currentZoomScale,
                strokeCount: currentStrokeCount,
                textboxes: textboxesData
            };
            updatePageUI();
        }

        function restorePageData(pageData) {
            // ãƒ†ã‚­ã‚¹ãƒˆãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¯ãƒªã‚¢
            textLayer.innerHTML = '';
            activeTextbox = null;
            rubyTools.style.opacity = '0.5';
            rubyTools.style.pointerEvents = 'none';

            if (!pageData) {
                mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
                currentStrokes = [];
                currentZoomScale = 1.0;
                currentStrokeCount = 0;
                applyZoom();
                return;
            }

            if (pageData.data) {
                mainCtx.putImageData(pageData.data, 0, 0);
            } else {
                mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            }

            currentStrokes = JSON.parse(JSON.stringify(pageData.strokes || []));
            currentStrokeCount = pageData.strokeCount || 0;

            // ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã®å¾©å…ƒ
            if (pageData.textboxes) {
                pageData.textboxes.forEach(tbData => {
                    const box = document.createElement('div');
                    box.id = tbData.id || `tb-${Date.now()}-${Math.random()}`;
                    box.className = 'floating-textbox';
                    box.contentEditable = "true";
                    box.spellcheck = false;
                    box.style.left = tbData.x;
                    box.style.top = tbData.y;
                    box.style.color = tbData.color || '#333333';
                    box.style.fontSize = tbData.fontSize || '24px';
                    box.innerHTML = tbData.html;
                    setupTextboxEvents(box);
                    textLayer.appendChild(box);
                });
            }

            currentZoomScale = pageData.zoomScale || 1.0;
            applyZoom();
        }
        // Undo(ã‚„ã‚Šç›´ã—)é–¢é€£
        function saveUndoState() {
            undoStack.push({
                image: mainCtx.getImageData(0, 0, mainCanvas.width, mainCanvas.height),
                strokes: JSON.parse(JSON.stringify(currentStrokes)),
                strokeCount: currentStrokeCount
            });
            if (undoStack.length > 20) undoStack.shift(); // å±¥æ­´æœ€å¤§20ä»¶åˆ¶é™
        }

        document.getElementById('btn-undo').addEventListener('click', () => {
            if (undoStack.length > 0) {
                let prevState = undoStack.pop();
                // å¾©å…ƒå‡¦ç†ï¼ˆrestorePageDataã¨ã»ã¼åŒã˜ã ãŒãƒ†ã‚­ã‚¹ãƒˆé–¢é€£ã‚’é™¤ãï¼‰
                mainCtx.putImageData(prevState.image, 0, 0);
                currentStrokes = JSON.parse(JSON.stringify(prevState.strokes || []));
                currentStrokeCount = prevState.strokeCount || 0;
                saveCurrentPage(); // undoç›´å¾Œã®çŠ¶æ…‹ã‚‚ãƒšãƒ¼ã‚¸ä¿å­˜ã¸åæ˜ 
            }
        });

        // ãƒšãƒ¼ã‚¸ç§»å‹•ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®é©ç”¨ã¨æç”»ãƒªã‚»ãƒƒãƒˆ
        function applyPageTurn(directionStr) {
            container.classList.remove('page-turn-next', 'page-turn-prev');
            // ãƒªãƒ•ãƒ­ãƒ¼å¼·åˆ¶
            void container.offsetWidth;
            container.classList.add(`page-turn-${directionStr}`);

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ä¸­é–“ç‚¹ã§ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’æ›¸ãæ›ãˆã‚‹
            setTimeout(() => {
                restorePageData(pages[currentPageIndex]);
            }, 200);

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†å¾Œã«ã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤
            setTimeout(() => {
                container.classList.remove(`page-turn-${directionStr}`);
            }, 400);
        }

        // æ¬¡ã®ãƒšãƒ¼ã‚¸ã¸ (å­˜åœ¨ã—ãªã„å ´åˆã¯æ–°è¦ä½œæˆ)
        document.getElementById('btn-next').addEventListener('click', () => {
            saveCurrentPage(); // é·ç§»å‰ã«ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¿å­˜
            undoStack = []; // ãƒšãƒ¼ã‚¸é·ç§»ã§Undoã‚¯ãƒªã‚¢
            if (currentPageIndex < pages.length - 1) {
                // æ—¢å­˜ã®æ¬¡ãƒšãƒ¼ã‚¸
                currentPageIndex++;
            } else {
                // æ–°è¦ãƒšãƒ¼ã‚¸è¿½åŠ 
                mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
                draftCtx.clearRect(0, 0, draftCanvas.width, draftCanvas.height);
                textLayer.innerHTML = ''; // å‰ã®ãƒšãƒ¼ã‚¸ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’é™¤å»
                activeTextbox = null;
                currentStrokes = [];
                currentStrokeCount = 0;
                currentPageIndex++;
                saveCurrentPage(); // çœŸã£ç™½ãªçŠ¶æ…‹ã‚’æ–°ã—ã„ãƒšãƒ¼ã‚¸ã¨ã—ã¦ä¿å­˜
            }
            applyPageTurn('next');
            updatePageUI();
        });

        // å‰ã®ãƒšãƒ¼ã‚¸ã¸
        document.getElementById('btn-prev').addEventListener('click', () => {
            if (currentPageIndex > 0) {
                saveCurrentPage(); // é·ç§»å‰ã«ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¿å­˜
                undoStack = [];
                currentPageIndex--;
                applyPageTurn('prev');
                updatePageUI();
            }
        });

        // å…¨æ¶ˆå»
        document.getElementById('btn-clear').addEventListener('click', () => {
            if (confirm(langSelect.value === 'ja' ? 'ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã‚’å…¨æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ' : 'Clear current page?')) {
                saveUndoState();
                mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
                draftCtx.clearRect(0, 0, draftCanvas.width, draftCanvas.height);
                textLayer.innerHTML = '';
                activeTextbox = null;
                currentStrokes = [];
                currentStrokeCount = 0;
                saveCurrentPage();
            }
        });

        /**
         * ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ï¼ˆPNGä¿å­˜ï¼‰
         */
        document.getElementById('btn-save').addEventListener('click', async () => {
            // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­ã¯å…¨ç”»é¢ã‚’ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤ºä»˜ãã§ãƒ–ãƒ­ãƒƒã‚¯
            const loadingOverlay = document.getElementById('loading-overlay');
            loadingOverlay.innerHTML = 'ç”»åƒåŒ–ã—ã¦ã„ã¾ã™...<br><span style="font-size: 0.8em; opacity: 0.8;">â€»åˆå›ã®ã¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚¨ãƒ³ã‚¸ãƒ³ã®èª­ã¿è¾¼ã¿ãŒå…¥ã‚‹ãŸã‚æ•°ç§’ã‹ã‹ã‚Šã¾ã™ã€‚</span>';
            loadingOverlay.style.display = 'flex';

            const originalTransform = canvasWrapper.style.transform;

            try {
                // html2canvasç­‰ã®æç”»ã‚ºãƒ¬ã‚’é˜²ããŸã‚ã€ä¸€æ™‚çš„ã«ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³(transform)ã‚’è§£é™¤
                canvasWrapper.style.transform = 'none';

                // èƒŒæ™¯ã‚‚å«ã‚ã¦ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã®ä¸€æ™‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ç”Ÿæˆ
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = mainCanvas.width;
                exportCanvas.height = mainCanvas.height;
                const ctx = exportCanvas.getContext('2d');

                const currentPaper = paperSelect.value;
                const scale = Number(gridSpacingInput.value);

                // èƒŒæ™¯ã®ãƒ™ãƒ¼ã‚¹è‰²æç”»
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

                if (currentPaper === 'kanji') {
                    ctx.strokeStyle = '#b3e0f2';
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([6, 6]);
                    for (let x = 60 * scale; x < exportCanvas.width; x += 120 * scale) {
                        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, exportCanvas.height); ctx.stroke();
                    }
                    for (let y = 60 * scale; y < exportCanvas.height; y += 120 * scale) {
                        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(exportCanvas.width, y); ctx.stroke();
                    }
                    ctx.strokeStyle = '#66c2eb';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]);
                    for (let x = 0; x < exportCanvas.width; x += 120 * scale) {
                        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, exportCanvas.height); ctx.stroke();
                    }
                    for (let y = 0; y < exportCanvas.height; y += 120 * scale) {
                        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(exportCanvas.width, y); ctx.stroke();
                    }
                } else if (currentPaper === 'vertical') {
                    ctx.strokeStyle = '#b3e0f2';
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([6, 6]);
                    for (let x = exportCanvas.width - (40 * scale); x > 0; x -= 80 * scale) {
                        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, exportCanvas.height); ctx.stroke();
                    }
                    ctx.strokeStyle = '#66c2eb';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]);
                    for (let x = exportCanvas.width; x > 0; x -= 80 * scale) {
                        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, exportCanvas.height); ctx.stroke();
                    }
                } else if (currentPaper === 'grid') {
                    ctx.strokeStyle = '#87ceeb';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([]);
                    for (let x = 0; x < exportCanvas.width; x += 30 * scale) {
                        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, exportCanvas.height); ctx.stroke();
                    }
                    for (let y = 0; y < exportCanvas.height; y += 30 * scale) {
                        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(exportCanvas.width, y); ctx.stroke();
                    }
                } else if (currentPaper === 'horizontal') {
                    ctx.strokeStyle = '#87ceeb';
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([]);
                    for (let y = 40 * scale; y < exportCanvas.height; y += 40 * scale) {
                        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(exportCanvas.width, y); ctx.stroke();
                    }
                } else if (currentPaper === 'tictactoe') {
                    const tttThickness = Number(document.getElementById('input-thickness').value);
                    ctx.strokeStyle = '#222222';
                    ctx.lineWidth = tttThickness * scale;
                    ctx.setLineDash([]);
                    ctx.lineCap = 'round';
                    let boardSize = 150 * scale;
                    let offsetX = (exportCanvas.width - boardSize) / 2;
                    let offsetY = (exportCanvas.height - boardSize) / 2;
                    ctx.save();
                    ctx.translate(offsetX, offsetY);
                    ctx.beginPath(); ctx.moveTo(10 * scale, 50 * scale); ctx.quadraticCurveTo(75 * scale, 52 * scale, 140 * scale, 48 * scale); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(10 * scale, 100 * scale); ctx.quadraticCurveTo(75 * scale, 98 * scale, 140 * scale, 102 * scale); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(50 * scale, 10 * scale); ctx.quadraticCurveTo(48 * scale, 75 * scale, 52 * scale, 140 * scale); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(100 * scale, 10 * scale); ctx.quadraticCurveTo(102 * scale, 75 * scale, 98 * scale, 140 * scale); ctx.stroke();
                    ctx.restore();
                }

                // æ‰‹æ›¸ãã‚­ãƒ£ãƒ³ãƒã‚¹ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åˆæˆ
                ctx.drawImage(mainCanvas, 0, 0);

                // ==========================
                // ãƒ†ã‚­ã‚¹ãƒˆ(HTML)ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åˆæˆ
                // ==========================
                // ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿ç”»åƒåŒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã™
                const boxes = textLayer.querySelectorAll('.floating-textbox');
                if (boxes.length > 0) {
                    if (!window.html2canvas) {
                        await new Promise((resolve, reject) => {
                            const script = document.createElement('script');
                            script.src = "https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js";
                            script.onload = resolve;
                            script.onerror = () => reject(new Error("Failed to load html2canvas."));
                            document.head.appendChild(script);
                        });
                    }

                    // ã‚­ãƒ£ãƒ¬ãƒƒãƒˆï¼ˆé¸æŠçŠ¶æ…‹ï¼‰ã®è§£é™¤ã¨ã€ä¸€æ™‚çš„ãªç‚¹ç·šã®æ¶ˆå»
                    if (window.getSelection) {
                        window.getSelection().removeAllRanges();
                    }
                    setActiveTextbox(null);

                    const originalBorders = [];
                    boxes.forEach(b => {
                        originalBorders.push(b.style.border);
                        b.style.border = 'none'; // ä¿å­˜ç”»åƒã«ã¯æ ç·šã‚’æ®‹ã•ãªã„
                    });

                    // ãƒ†ã‚­ã‚¹ãƒˆãƒ¬ã‚¤ãƒ¤ãƒ¼å…¨ä½“ã‚’é€æ˜ãªã‚­ãƒ£ãƒ³ãƒã‚¹ã¨ã—ã¦æç”»
                    const textImgCanvas = await html2canvas(textLayer, {
                        backgroundColor: null,
                        scale: 1,
                        logging: false
                    });

                    // ä¸€æ™‚çš„ã«æ¶ˆã—ãŸç‚¹ç·šã‚’å¾©æ—§
                    boxes.forEach((b, idx) => {
                        b.style.border = originalBorders[idx];
                    });

                    // ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ãƒ¡ã‚¤ãƒ³ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆç”¨ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ä¸Šã‹ã‚‰åˆæˆ
                    ctx.drawImage(textImgCanvas, 0, 0, exportCanvas.width, exportCanvas.height);
                }

                // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã®å®Ÿè¡Œ
                const dataURL = exportCanvas.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = dataURL;
                a.download = `freenote_${new Date().getTime()}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

            } catch (err) {
                console.error("PNGä¿å­˜ã‚¨ãƒ©ãƒ¼:", err);
                alert("ç”»åƒã®ä¿å­˜ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚\n" + err.message);
            } finally {
                canvasWrapper.style.transform = originalTransform;
                loadingOverlay.style.display = 'none';
            }
        });

        /**
         * ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ èƒŒæ™¯æ›´æ–°
         */
        function updatePaperBackground() {
            const type = paperSelect.value;
            const scale = Number(gridSpacingInput.value);
            // æ—¢å­˜ã®ã€Œç·šã®å¤ªã•ã€ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®å€¤ã‚’æ ç·šã«ã‚‚é©ç”¨
            const tttThickness = Number(thicknessInput.value);
            canvasWrapper.className = `paper-${type}`;

            // ç”¨ç´™ã‚¿ã‚¤ãƒ—ã«ã‚ˆã‚‹åˆ¶é™ã‚’æ’¤å»ƒã—æœ€å¤§10.0ã¾ã§æ‹¡å¤§ã‚’è¨±å¯
            gridSpacingInput.max = "10.0";

            let svg = '';
            let size = '';
            let pos = '';

            if (type === 'kanji') {
                let rawSvg = `<svg xmlns='http://www.w3.org/2000/svg' width='${120 * scale}' height='${120 * scale}'><rect width='${120 * scale}' height='${120 * scale}' fill='#ffffff'/><path d='M${60 * scale} 0 v${120 * scale} M0 ${60 * scale} h${120 * scale}' stroke='#b3e0f2' stroke-width='1.5' stroke-dasharray='6,6'/><path d='M${120 * scale} 0 L0 0 0 ${120 * scale}' fill='none' stroke='#66c2eb' stroke-width='2'/></svg>`;
                svg = `url("data:image/svg+xml;charset=utf-8,${encodeURIComponent(rawSvg)}")`;
                size = `${120 * scale}px ${120 * scale}px`;
                pos = 'top left';
            } else if (type === 'vertical') {
                let rawSvg = `<svg xmlns='http://www.w3.org/2000/svg' width='${80 * scale}' height='${40 * scale}'><rect width='${80 * scale}' height='${40 * scale}' fill='#ffffff'/><path d='M40 * scale} 0 v${40 * scale}' stroke='#b3e0f2' stroke-width='1.5' stroke-dasharray='6,6'/><path d='M0 0 v${40 * scale}' fill='none' stroke='#66c2eb' stroke-width='2'/></svg>`;
                svg = `url("data:image/svg+xml;charset=utf-8,${encodeURIComponent(rawSvg)}")`;
                size = `${80 * scale}px ${40 * scale}px`;
                pos = 'top right';
            } else if (type === 'grid') {
                let rawSvg = `<svg xmlns='http://www.w3.org/2000/svg' width='${30 * scale}' height='${30 * scale}'><rect width='${30 * scale}' height='${30 * scale}' fill='#ffffff'/><path d='M${30 * scale} 0 L0 0 0 ${30 * scale}' fill='none' stroke='#87ceeb' stroke-width='1'/></svg>`;
                svg = `url("data:image/svg+xml;charset=utf-8,${encodeURIComponent(rawSvg)}")`;
                size = `${30 * scale}px ${30 * scale}px`;
                pos = 'top left';
            } else if (type === 'horizontal') {
                let rawSvg = `<svg xmlns='http://www.w3.org/2000/svg' width='${40 * scale}' height='${40 * scale}'><rect width='${40 * scale}' height='${40 * scale}' fill='#ffffff'/><path d='M0 ${40 * scale} h${40 * scale}' fill='none' stroke='#87ceeb' stroke-width='1.5'/></svg>`;
                svg = `url("data:image/svg+xml;charset=utf-8,${encodeURIComponent(rawSvg)}")`;
                size = `${40 * scale}px ${40 * scale}px`;
                pos = 'top left';
            } else if (type === 'tictactoe') {
                let boardSize = 150 * scale;
                let strokeW = tttThickness * scale;
                let rawSvg = `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 ${boardSize} ${boardSize}' width='${boardSize}' height='${boardSize}'><path d='M${10 * scale} ${50 * scale} Q${75 * scale} ${52 * scale} ${140 * scale} ${48 * scale} M${10 * scale} ${100 * scale} Q${75 * scale} ${98 * scale} ${140 * scale} ${102 * scale} M${50 * scale} ${10 * scale} Q${48 * scale} ${75 * scale} ${52 * scale} ${140 * scale} M${100 * scale} ${10 * scale} Q${102 * scale} ${75 * scale} ${98 * scale} ${140 * scale}' fill='none' stroke='#222222' stroke-width='${strokeW}' stroke-linecap='round'/></svg>`;
                svg = `url("data:image/svg+xml;charset=utf-8,${encodeURIComponent(rawSvg)}")`;
                size = `${boardSize}px ${boardSize}px`;
                pos = 'center center';
            } else {
                svg = 'none';
                size = 'auto';
                pos = '0% 0%';
            }

            canvasWrapper.style.backgroundImage = svg;
            canvasWrapper.style.backgroundSize = size;
            canvasWrapper.style.backgroundPosition = pos;
            canvasWrapper.style.backgroundRepeat = type === 'tictactoe' ? 'no-repeat' : 'repeat';
        }

        paperSelect.addEventListener('change', updatePaperBackground);
        gridSpacingInput.addEventListener('input', updatePaperBackground);
        thicknessInput.addEventListener('input', updatePaperBackground); // ãƒšãƒ³ã®å¤ªã•å¤‰æ›´æ™‚ã«ã‚‚èƒŒæ™¯ã‚’å†æç”»

        // åˆå›ãƒ­ãƒ¼ãƒ‰æ™‚ã«é©ç”¨
        updatePaperBackground();

        // ã‚¹ãƒãƒ›æ™‚ã«ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚’éš ã™ãŸã‚ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
        window.addEventListener('load', () => {
            setTimeout(() => {
                window.scrollTo(0, 1);
                currentStrokes = [];
                saveCurrentPage();
            }, 100);
        });

        // ==========================================
        // ã‚¨ãƒ‡ã‚£ã‚¿ï¼ˆæµ®å‹•ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ï¼‰é–¢é€£
        // ==========================================

        function createFloatingTextbox(x, y) {
            const box = document.createElement('div');
            box.id = `tb-${Date.now()}-${textboxIdCounter++}`;
            box.className = 'floating-textbox';
            box.contentEditable = "true";
            box.spellcheck = false;

            // ã‚ºãƒ¼ãƒ ã¨ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’è€ƒæ…®ã—ãŸåº§æ¨™è¨ˆç®—ï¼ˆé…ç½®æ™‚ã«æŒ‡ã®å°‘ã—å·¦ä¸Šã«æ¥ã‚‹ã‚ˆã†èª¿æ•´ï¼‰
            const rect = canvasWrapper.getBoundingClientRect();
            const scaledX = (x - rect.left - 20) / currentZoomScale;
            const scaledY = (y - rect.top - 20) / currentZoomScale;

            box.style.left = `${scaledX}px`;
            box.style.top = `${scaledY}px`;

            // ç¾åœ¨ã®ãƒ„ãƒ¼ãƒ«ãƒãƒ¼è¨­å®šã‚’é©ç”¨
            box.style.color = currentColor;
            box.style.fontSize = `${document.getElementById('input-font-size').value || 24}px`;

            setupTextboxEvents(box);
            textLayer.appendChild(box);

            // ç”Ÿæˆç›´å¾Œã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã•ã›ã¦å…¥åŠ›ã‚’ä¿ƒã™
            setTimeout(() => {
                box.focus();
                setActiveTextbox(box);
            }, 10);

            saveCurrentPage();
        }

        function setActiveTextbox(box) {
            activeTextbox = box;
            if (box) {
                rubyTools.style.opacity = '1';
                rubyTools.style.pointerEvents = 'auto';

                // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’ç¾åœ¨ã®ãƒœãƒƒã‚¯ã‚¹ã«åˆã‚ã›ã‚‹
                // window.getComputedStyle(box).fontSize ã‚’ä½¿ç”¨
                const currentSize = parseFloat(window.getComputedStyle(box).fontSize) || 24;
                document.getElementById('input-font-size').value = Math.round(currentSize);
            } else {
                rubyTools.style.opacity = '0.5';
                rubyTools.style.pointerEvents = 'none';
            }
        }

        function setupTextboxEvents(box) {
            let isDragging = false;
            let dragStartX, dragStartY;
            let initialLeft, initialTop;

            box.addEventListener('focus', () => {
                setActiveTextbox(box);
            });

            box.addEventListener('blur', (e) => {
                // ã™ãã«å‰Šé™¤ã›ãšã€æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–è¦ç´ ï¼ˆã‚¯ãƒªãƒƒã‚¯å…ˆï¼‰ã‚’åˆ¤å®šã™ã‚‹ãŸã‚ã®çŒ¶äºˆã‚’è¨­ã‘ã‚‹
                setTimeout(() => {
                    // ã‚‚ã—å†ã³ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’å–ã‚Šæˆ»ã—ã¦ã„ãŸã‚‰ä½•ã‚‚ã—ãªã„
                    if (document.activeElement === box) return;

                    // ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ï¼ˆè¨€èªé¸æŠã‚„ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºï¼‰ã®æ“ä½œä¸­ã¯ã€ç©ºã§ã‚‚ç¶­æŒã™ã‚‹
                    const activeEl = document.activeElement;
                    if (activeEl && (activeEl.closest('#ruby-tools') || activeEl.closest('#draw-tools'))) {
                        return;
                    }

                    // ç©ºã«ãªã£ãŸã‚‰ï¼ˆã‹ã¤ãƒ„ãƒ¼ãƒ«æ“ä½œä¸­ã§ãªã‘ã‚Œã°ï¼‰å‰Šé™¤
                    if (!box.textContent.trim()) {
                        box.remove();
                        if (activeTextbox === box) setActiveTextbox(null);
                        saveCurrentPage();
                    }
                }, 150);
            });

            box.addEventListener('input', () => {
                // å…¥åŠ›ãŒã‚ã£ãŸã‚‰å³åº§ã«ä¿å­˜
                // TODO: Undoã‚¹ã‚¿ãƒƒã‚¯ã®å®Ÿè£…ãŒå¿…è¦ãªå ´åˆã¯ã“ã“ã«ãƒ•ãƒƒã‚¯
                saveCurrentPage();
            });

            // ãƒ‰ãƒ©ãƒƒã‚°ç§»å‹•ï¼ˆã‚­ãƒ£ãƒ¬ãƒƒãƒˆç§»å‹•ã¨è¡çªã—ãªã„ã‚ˆã†ä½™ç™½ãªã©ã‚’æ´ã‚“ã æ™‚ã®ã¿ï¼‰
            box.addEventListener('pointerdown', (e) => {
                if (brushSelect.value.startsWith('eraser')) {
                    // æ¶ˆã—ã‚´ãƒ ãƒ„ãƒ¼ãƒ«ãªã‚‰ç®±ã”ã¨å‰Šé™¤
                    box.remove();
                    saveCurrentPage();
                    if (activeTextbox === box) setActiveTextbox(null);
                    e.stopPropagation();
                } else if (activeTextbox === box) {
                    // ã™ã§ã«é¸æŠï¼ˆãƒ•ã‚©ãƒ¼ã‚«ã‚¹ï¼‰ä¸­ã®å ´åˆã¯ã€ãƒ†ã‚­ã‚¹ãƒˆç·¨é›†ã¨ã—ã¦ã®æ“ä½œã‚’å„ªå…ˆã•ã›ã‚‹
                    e.stopPropagation();
                } else {
                    // éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã®ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã«è§¦ã‚ŒãŸå ´åˆã¯ã¾ãšãƒ‰ãƒ©ãƒƒã‚°ç§»å‹•ãƒ¢ãƒ¼ãƒ‰ã«ã™ã‚‹
                    isDragging = true;
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    initialLeft = parseFloat(box.style.left) || 0;
                    initialTop = parseFloat(box.style.top) || 0;
                    box.style.cursor = 'grabbing';
                    e.stopPropagation();
                    // ã‚¹ãƒãƒ›ã§ã‚­ãƒ£ãƒ¬ãƒƒãƒˆãŒç«‹ãŸãªã„ã‚ˆã†ã«ã™ã‚‹ï¼ˆãƒ‰ãƒ©ãƒƒã‚°å„ªå…ˆï¼‰
                    e.preventDefault();
                }
            });

            window.addEventListener('pointermove', (e) => {
                if (!isDragging) return;
                const dx = (e.clientX - dragStartX) / currentZoomScale;
                const dy = (e.clientY - dragStartY) / currentZoomScale;
                box.style.left = `${initialLeft + dx}px`;
                box.style.top = `${initialTop + dy}px`;
            });

            window.addEventListener('pointerup', (e) => {
                if (isDragging) {
                    isDragging = false;
                    box.style.cursor = 'text';

                    const distMoved = Math.hypot(e.clientX - dragStartX, e.clientY - dragStartY);
                    if (distMoved < 3) {
                        // ã»ã¨ã‚“ã©ç§»å‹•ã—ã¦ã„ãªã‘ã‚Œã°ã€Œã‚¯ãƒªãƒƒã‚¯ã€ã¨ã¿ãªã—ã¦ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã™ã‚‹
                        box.focus();
                        setActiveTextbox(box);
                    } else {
                        // ç§»å‹•ã—ã¦ã„ãŸå ´åˆã¯ä½ç½®ã‚’ä¿å­˜
                        saveCurrentPage();
                    }
                }
            });

            // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§å¼·åˆ¶ç·¨é›†ãƒ¢ãƒ¼ãƒ‰
            box.addEventListener('dblclick', (e) => {
                box.focus();
                setActiveTextbox(box);
                e.stopPropagation();
            });

            // ãƒ«ãƒ“ã®ã‚¯ãƒªãƒƒã‚¯ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹å†…ï¼‰
            box.addEventListener('click', (e) => {
                const rt = e.target.closest('rt');
                if (rt) return; // RTã®ä¸­ã¯ãã®ã¾ã¾ç·¨é›†ã•ã›ã‚‹

                const ruby = e.target.closest('ruby');
                if (ruby) {
                    const targetRuby = ruby || rt.closest('ruby');
                    if (targetRuby) {
                        const baseChar = Array.from(targetRuby.childNodes).find(n => n.nodeType === Node.TEXT_NODE)?.textContent;
                        if (!baseChar || !baseChar.trim()) return;

                        const lang = document.getElementById('select-ruby-lang').value;
                        if (lang === 'zh') {
                            const dict = window.pinyinPro.pinyin(baseChar.trim(), { multiple: true, type: 'array' });
                            if (dict && dict.length > 1) {
                                const newPinyin = prompt(`ã€${baseChar.trim()}ã€‘ã®èª­ã¿ï¼ˆå¤šéŸ³å­—ï¼‰å€™è£œ: ${dict.join(', ')}\nè‡ªç”±ã«ç·¨é›†å¯èƒ½ã§ã™ã€‚`, targetRuby.querySelector('rt')?.textContent || '');
                                if (newPinyin !== null) {
                                    let rrt = targetRuby.querySelector('rt');
                                    if (!rrt) {
                                        rrt = document.createElement('rt');
                                        targetRuby.appendChild(rrt);
                                    }
                                    rrt.textContent = newPinyin;
                                    saveCurrentPage();
                                }
                            }
                        } else if (lang === 'ja') {
                            const currentRt = targetRuby.querySelector('rt');
                            const newFurigana = prompt(`ã€${baseChar.trim()}ã€‘ã®èª­ã¿ã‚’å…¥åŠ›:`, currentRt ? currentRt.textContent : '');
                            if (newFurigana !== null) {
                                if (!currentRt) {
                                    targetRuby.insertAdjacentHTML('beforeend', `<rt>${newFurigana}</rt>`);
                                } else {
                                    currentRt.textContent = newFurigana;
                                }
                                saveCurrentPage();
                            }
                        }
                    }
                }
            });
        }

        window.isTextPlacementMode = false;

        // ç‹¬ç«‹ã—ãŸãƒ†ã‚­ã‚¹ãƒˆè¿½åŠ ãƒœã‚¿ãƒ³
        document.getElementById('btn-add-text').addEventListener('click', () => {
            window.isTextPlacementMode = !window.isTextPlacementMode;
            const btn = document.getElementById('btn-add-text');
            if (window.isTextPlacementMode) {
                container.style.cursor = 'crosshair';
                btn.style.backgroundColor = '#007aff'; // é¸æŠä¸­ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼ˆé’ï¼‰
                btn.style.color = '#ffffff'; // æ–‡å­—ã‚’ç™½ã«
                btn.style.borderColor = '#007aff';
            } else {
                container.style.cursor = brushSelect.value === 'text' ? 'text' : 'crosshair';
                btn.style.backgroundColor = '';
                btn.style.color = '';
                btn.style.borderColor = '';
            }
        });

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ä½•ã‚‚ãªã„ã¨ã“ã‚ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸæ™‚
        container.addEventListener('click', (e) => {
            if (e.target === container || e.target === draftCanvas || e.target === mainCanvas || e.target === textLayer) {

                // ãƒ†ã‚­ã‚¹ãƒˆé…ç½®ãƒ¢ãƒ¼ãƒ‰ãªã‚‰ã€ãã®ä½ç½®ã«ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã‚’ç”Ÿæˆ
                if (window.isTextPlacementMode) {
                    createFloatingTextbox(e.clientX, e.clientY);
                    window.isTextPlacementMode = false;
                    container.style.cursor = brushSelect.value === 'text' ? 'text' : 'crosshair';
                    const btn = document.getElementById('btn-add-text');
                    btn.style.backgroundColor = '';
                    btn.style.color = '';
                    btn.style.borderColor = '';
                    return;
                }

                // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹è§£é™¤ã®ã¿è¡Œã†
                if (activeTextbox && e.target !== activeTextbox && !activeTextbox.contains(e.target)) {
                    setActiveTextbox(null);
                }
            }

            // ãƒ«ãƒ“(ruby/rt)ã®ã‚¿ãƒƒãƒ—ç·¨é›†ã‚’æœ€å„ªå…ˆã§å‡¦ç†
            let target = e.target;
            const rubyNode = target.closest('ruby');
            if (rubyNode) {
                const rtNode = rubyNode.querySelector('rt');
                const baseText = Array.from(rubyNode.childNodes)
                    .filter(node => node.nodeType === Node.TEXT_NODE)
                    .map(node => node.textContent)
                    .join('');

                const currentRt = rtNode ? rtNode.textContent : "";
                const newRt = prompt(`ã€Œ${baseText}ã€ã®ãƒ«ãƒ“ã‚’ç·¨é›†:`, currentRt);

                if (newRt !== null) {
                    if (newRt.trim() === '') {
                        // ãƒ«ãƒ“ã‚’ç©ºã«ã—ãŸå ´åˆã¯<ruby>ã‚¿ã‚°ã‚’è§£é™¤ã—ã¦å…ƒã®æ–‡å­—ã«æˆ»ã™
                        rubyNode.replaceWith(document.createTextNode(baseText));
                    } else if (rtNode) {
                        rtNode.textContent = newRt;
                    } else {
                        // rtãŒãªã‹ã£ãŸå ´åˆã€æ–°ã—ãä½œæˆ
                        const newRtElement = document.createElement('rt');
                        newRtElement.textContent = newRt;
                        rubyNode.appendChild(newRtElement);
                    }
                    saveCurrentPage();
                }
                return; // ã“ã“ã§å®Œäº†
            }
        });

        document.getElementById('input-font-size').addEventListener('input', (e) => {
            if (activeTextbox) {
                activeTextbox.style.fontSize = `${e.target.value}px`;
                saveCurrentPage();
            }
        });

        // è¾æ›¸ä¸è¦ãƒ»è‡ªå·±å®Œçµå‹ã®ãƒ«ãƒ“å‡¦ç†
        async function applyRubyToEditor() {
            if (!activeTextbox) {
                alert("ãƒ«ãƒ“ã‚’æŒ¯ã‚‹ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã‚’ã‚¿ãƒƒãƒ—ã—ã¦é¸æŠã—ã¦ãã ã•ã„ã€‚");
                return;
            }

            const lang = document.getElementById('select-ruby-lang').value;

            if (lang === 'ja') {
                // æ—¥æœ¬èª: è¾æ›¸éæ­è¼‰ã«ã‚ˆã‚‹æ‰‹å‹•ãƒ«ãƒ“æŒ¯ã‚Š
                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const range = selection.getRangeAt(0);
                const selectedText = selection.toString();

                if (!selectedText.trim() || !activeTextbox.contains(range.commonAncestorContainer)) {
                    alert("ãƒ«ãƒ“ã‚’æŒ¯ã‚ŠãŸã„æ–‡å­—ã‚’ãªãã£ã¦ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆé¸æŠï¼‰ã—ã¦ã‹ã‚‰ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚\nâ€»ã™ã§ã«æŒ¯ã‚‰ã‚Œã¦ã„ã‚‹ãƒ«ãƒ“ã‚’ä¿®æ­£ã—ãŸã„å ´åˆã¯ã€ãã®ãƒ«ãƒ“ã‚’ç›´æ¥ã‚¿ãƒƒãƒ—ã—ã¦ãã ã•ã„ã€‚");
                    return;
                }

                const rubyText = prompt(`ã€Œ${selectedText}ã€ã®ãƒ«ãƒ“ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:`);
                if (rubyText !== null && rubyText.trim() !== '') {
                    // é¸æŠç¯„å›²ã‚’<ruby>ã‚¿ã‚°ã§å®‰å…¨ã«ãƒ©ãƒƒãƒ—ã™ã‚‹
                    const rubyHtml = `<ruby>${selectedText}<rt>${rubyText}</rt></ruby>`;
                    document.execCommand('insertHTML', false, rubyHtml);
                    saveCurrentPage();
                }
            } else {
                // ä¸­å›½èª: è¾æ›¸ä¸è¦ï¼ˆçµ„è¾¼ãƒˆãƒ©ã‚¤æœ¨ï¼‰ã®pinyin-proã«ã‚ˆã‚‹è‡ªå‹•ãƒ«ãƒ“æŒ¯ã‚Š
                // æ—¢å­˜ã®rtç­‰ã‚’ç„¡è¦–ã—ã¦ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ½å‡º
                function extractTextIgnoreRt(node) {
                    if (node.nodeType === Node.TEXT_NODE) return node.nodeValue;
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        if (node.tagName === 'RT') return '';
                        if (node.tagName === 'BR') return '\n';
                        let text = '';
                        for (let child of node.childNodes) text += extractTextIgnoreRt(child);
                        if (node.tagName === 'DIV' || node.tagName === 'P') text += '\n';
                        return text;
                    }
                    return '';
                }

                let plainText = extractTextIgnoreRt(activeTextbox);
                plainText = plainText.replace(/\n{3,}/g, '\n\n').replace(/\n+$/, '');
                if (!plainText.trim()) return;

                document.getElementById('loading-overlay').style.display = 'flex';
                try {
                    const pinyinArray = window.pinyinPro.pinyin(plainText, { type: 'array' });
                    let htmlStr = '';
                    for (let i = 0; i < plainText.length; i++) {
                        const char = plainText[i];
                        if (char === '\n') {
                            htmlStr += '<br>';
                        } else if (/[\u4e00-\u9fa5]/.test(char)) {
                            htmlStr += `<ruby>${char}<rt>${pinyinArray[i] || ''}</rt></ruby>`;
                        } else {
                            htmlStr += char;
                        }
                    }
                    activeTextbox.innerHTML = htmlStr;
                    saveCurrentPage();
                } catch (e) {
                    console.error(e);
                    alert('ãƒ«ãƒ“æŒ¯ã‚Šä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚\n' + e.message);
                } finally {
                    document.getElementById('loading-overlay').style.display = 'none';
                }
            }
        }

        document.getElementById('btn-auto-ruby').addEventListener('click', applyRubyToEditor);

        // ã‚ºãƒ¼ãƒ ã¨ãƒ‘ãƒ³ï¼ˆãƒ”ãƒ³ãƒï¼†ã‚¹ãƒ¯ã‚¤ãƒ—ï¼‰ã®ã‚µãƒãƒ¼ãƒˆ
        let currentZoomScale = 1.0;
        let currentTranslateX = 0;
        let currentTranslateY = 0;

        let isPinching = false;
        let initialPinchDistance = null;
        let initialZoomScale = 1.0;
        let initialTouchesCenter = null;
        let initialTranslateX = 0;
        let initialTranslateY = 0;

        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.hypot(dx, dy);
        }

        function getTouchesCenter(touches) {
            return {
                x: (touches[0].clientX + touches[1].clientX) / 2,
                y: (touches[0].clientY + touches[1].clientY) / 2
            };
        }

        function handleTouchStart(e) {
            if (e.touches.length >= 2) {
                isPinching = true;
                initialPinchDistance = getPinchDistance(e.touches);
                initialZoomScale = currentZoomScale;
                initialTouchesCenter = getTouchesCenter(e.touches);
                initialTranslateX = currentTranslateX;
                initialTranslateY = currentTranslateY;
            }
        }

        function handleTouchMove(e) {
            if (isPinching && e.touches.length >= 2 && initialPinchDistance) {
                if (e.cancelable) e.preventDefault(); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒ»ã‚ºãƒ¼ãƒ ã‚’é˜²ã
                const currentDistance = getPinchDistance(e.touches);
                const ratio = currentDistance / initialPinchDistance;
                currentZoomScale = Math.min(Math.max(0.2, initialZoomScale * ratio), 5.0);

                const currentCenter = getTouchesCenter(e.touches);
                const dx = currentCenter.x - initialTouchesCenter.x;
                const dy = currentCenter.y - initialTouchesCenter.y;

                // ã‚ºãƒ¼ãƒ ã®ä¸­å¿ƒã‚’ç¶­æŒã™ã‚‹ãŸã‚ã®ãƒ‘ãƒ³ï¼ˆç§»å‹•ï¼‰è¨ˆç®—
                const zoomRatio = currentZoomScale / initialZoomScale;
                currentTranslateX = initialTranslateX + dx - (initialTouchesCenter.x - initialTranslateX) * (zoomRatio - 1);
                currentTranslateY = initialTranslateY + dy - (initialTouchesCenter.y - initialTranslateY) * (zoomRatio - 1);

                applyZoom();
            }
        }

        function handleTouchEnd(e) {
            if (e.touches.length < 2) {
                isPinching = false;
                initialPinchDistance = null;
            }
        }

        function applyZoom() {
            canvasWrapper.style.transform = `translate(${currentTranslateX}px, ${currentTranslateY}px) scale(${currentZoomScale})`;
        }

        container.addEventListener('touchstart', handleTouchStart, { passive: false });
        container.addEventListener('touchmove', handleTouchMove, { passive: false });
        container.addEventListener('touchend', handleTouchEnd);
        container.addEventListener('touchcancel', handleTouchEnd);

    </script>
</body>

</html>